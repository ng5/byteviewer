<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bit Fiddling Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            padding: 10px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1880px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: 1.8em;
        }

        .subtitle {
            text-align: center;
            color: #b0b0b0;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .section {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #404040;
            border-radius: 4px;
            font-size: 14px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
        }

        input:focus {
            outline: none;
            border-color: #606060;
        }

        .expressions-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .expressions-table th {
            background: #3a3a3a;
            color: #e0e0e0;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
            border: 1px solid #404040;
        }

        .expressions-table td {
            padding: 8px;
            border: 1px solid #404040;
            background: #252525;
        }

        .expressions-table tr:hover {
            background: #2a2a2a;
        }

        .expr-input {
            width: 100%;
            padding: 6px;
            border: 1px solid #404040;
            border-radius: 3px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .expr-input:focus {
            outline: none;
            border-color: #606060;
        }

        .binary-output {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #d0d0d0;
            word-break: break-all;
            letter-spacing: 1px;
        }

        .binary-group {
            display: inline-block;
            margin-right: 8px;
        }

        .decimal-output {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #d0d0d0;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-add {
            background: #4a4a4a;
            color: #e0e0e0;
            margin-right: 10px;
        }

        .btn-add:hover {
            background: #5a5a5a;
        }

        .btn-remove {
            background: #3a3a3a;
            color: #ff6b6b;
            padding: 4px 8px;
            font-size: 0.85em;
        }

        .btn-remove:hover {
            background: #ff6b6b;
            color: #1a1a1a;
        }

        .controls {
            margin-top: 15px;
        }

        .error-cell {
            color: #ff6b6b;
            font-size: 0.85em;
        }

        .intermediate-steps {
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid #404040;
        }

        .step-row {
            display: flex;
            align-items: center;
            padding: 3px 0;
            font-size: 11px;
        }

        .step-label {
            color: #808080;
            min-width: 30px;
            font-style: italic;
        }

        .step-expr {
            color: #909090;
            font-family: 'Courier New', monospace;
            margin-right: 10px;
            min-width: 120px;
        }

        .step-binary {
            font-family: 'Courier New', monospace;
            color: #a0a0a0;
            font-size: 10px;
            letter-spacing: 1px;
        }

        .step-decimal {
            color: #909090;
            font-family: 'Courier New', monospace;
            margin-left: 10px;
            font-size: 11px;
        }

        .toggle-steps {
            cursor: pointer;
            color: #808080;
            font-size: 0.8em;
            margin-top: 3px;
            user-select: none;
        }

        .toggle-steps:hover {
            color: #a0a0a0;
        }

        .step-arrow {
            color: #606060;
            margin-right: 5px;
        }

        .width-selector {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            font-size: 0.85em;
            font-weight: normal;
        }

        .width-option {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .width-option input[type="radio"] {
            cursor: pointer;
        }

        .width-option label {
            cursor: pointer;
            margin: 0;
            color: #d0d0d0;
            font-weight: normal;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Bit Fiddling Playground</h1>
        <div class="subtitle" style="font-size: 0.75em; color: #808080;">Note: Some techniques were historically
            patented but are now expired/public domain. Check current patent status for commercial use.</div>

        <div class="section">
            <div class="input-group">
                <label for="numberInput">Enter Decimal Number (use 'x' in expressions):</label>
                <input type="number" id="numberInput" placeholder="e.g., 10" value="42">
            </div>

            <table class="expressions-table">
                <thead>
                    <tr>
                        <th style="width: 18%;">Description</th>
                        <th style="width: 30%;">Expression</th>
                        <th style="width: 40%;">
                            <div>Binary Result (Little Endian)</div>
                            <div class="width-selector">
                                <div class="width-option">
                                    <input type="radio" id="width8" name="bitWidth" value="8">
                                    <label for="width8">8-bit</label>
                                </div>
                                <div class="width-option">
                                    <input type="radio" id="width16" name="bitWidth" value="16">
                                    <label for="width16">16-bit</label>
                                </div>
                                <div class="width-option">
                                    <input type="radio" id="width32" name="bitWidth" value="32">
                                    <label for="width32">32-bit</label>
                                </div>
                                <div class="width-option">
                                    <input type="radio" id="width64" name="bitWidth" value="64" checked>
                                    <label for="width64">64-bit</label>
                                </div>
                            </div>
                        </th>
                        <th style="width: 10%;">Decimal Result</th>
                        <th style="width: 2%;"></th>
                    </tr>
                </thead>
                <tbody id="expressionsBody">
                </tbody>
            </table>

            <div class="controls">
                <button class="btn btn-add" onclick="addRow('', '')">+ Add Expression</button>
            </div>
        </div>
    </div>

    <script>
        const numberInput = document.getElementById('numberInput');
        const expressionsBody = document.getElementById('expressionsBody');

        let rowCounter = 0;
        let currentBitWidth = 64; // Default to 64-bit

        function determineBitWidth(num) {
            // Determine the minimum bit width needed (8, 16, 32, or 64)
            const absNum = Math.abs(num);

            if (absNum <= 0x7F && num >= -0x80) return 8;        // Fits in 8 bits
            if (absNum <= 0x7FFF && num >= -0x8000) return 16;   // Fits in 16 bits
            if (absNum <= 0x7FFFFFFF && num >= -0x80000000) return 32; // Fits in 32 bits
            return 64; // Needs 64 bits
        }

        function checkFitsInWidth(num, width) {
            // Check if a number fits in the specified bit width (signed)
            const bigNum = BigInt(num);
            const maxVal = (1n << BigInt(width - 1)) - 1n;  // Max positive value
            const minVal = -(1n << BigInt(width - 1));       // Min negative value

            return bigNum >= minVal && bigNum <= maxVal;
        }

        function formatBinary(num, width = 64) {
            // Check if number fits in the specified width
            if (!checkFitsInWidth(num, width)) {
                return { error: true, message: 'Insufficient width' };
            }

            // Convert to binary representation with specified width
            let binary;

            if (num < 0) {
                // For negative numbers, use two's complement
                const bigNum = BigInt(num);
                const mask = (1n << BigInt(width)) - 1n;
                binary = (bigNum & mask).toString(2).padStart(width, '0');
            } else {
                binary = BigInt(num).toString(2).padStart(width, '0');
            }

            // Split into groups of 8 for readability
            let formatted = '';
            for (let i = 0; i < width; i += 8) {
                formatted += `<span class="binary-group">${binary.substring(i, i + 8)}</span>`;
            }

            return { error: false, value: formatted };
        }

        // Keep old function name for compatibility but use new one
        function formatBinary64(num) {
            return formatBinary(num, currentBitWidth);
        }

        function evaluateExpression(expr, x) {
            try {
                // Sanitize expression - allow only safe characters including hex (a-f) and ternary operator (? :)
                if (!/^[x0-9a-fA-F+\-*\/%&|^~()<>\s?:]+$/.test(expr)) {
                    return { error: 'Invalid characters in expression' };
                }

                // Convert expression to use BigInt
                // First convert hex literals (0x...), then decimal numbers
                let convertedExpr = expr
                    .replace(/0x[0-9a-fA-F]+/g, match => `BigInt(${match})`)  // Convert hex to BigInt
                    .replace(/\b(\d+)\b/g, 'BigInt($1)')                      // Convert decimal to BigInt
                    .replace(/\bx\b/g, 'xBig');                               // Replace x with xBig

                // Create a safe evaluation context
                const safeEval = new Function('x', `
                    'use strict';
                    try {
                        // Convert x to BigInt for operations
                        const xBig = BigInt(x);

                        // Evaluate the converted expression
                        const result = ${convertedExpr};

                        // Convert back to number if small enough, otherwise keep as BigInt
                        if (result >= -(2n**53n) && result <= (2n**53n)) {
                            return Number(result);
                        }
                        return result;
                    } catch (e) {
                        return { error: e.message };
                    }
                `);

                const result = safeEval(x);

                if (result && typeof result === 'object' && result.error) {
                    return result;
                }

                return { value: result };
            } catch (e) {
                return { error: e.message };
            }
        }

        function extractIntermediateSteps(expr, x) {
            const steps = [];

            // Always start with x
            steps.push({ expr: 'x', value: x, description: 'input' });

            // Track unique sub-expressions to avoid duplicates
            const seen = new Set(['x']);

            // Find all parenthesized sub-expressions recursively
            const findSubExpressions = (str) => {
                const subExprs = [];
                let depth = 0;
                let start = -1;

                for (let i = 0; i < str.length; i++) {
                    if (str[i] === '(') {
                        if (depth === 0) start = i;
                        depth++;
                    } else if (str[i] === ')') {
                        depth--;
                        if (depth === 0 && start !== -1) {
                            const subExpr = str.substring(start + 1, i);
                            if (!seen.has(subExpr) && (subExpr.includes('x') || /[&|^~<>]/.test(subExpr))) {
                                subExprs.push(subExpr);
                                seen.add(subExpr);
                                // Recursively find sub-expressions within this one
                                subExprs.push(...findSubExpressions(subExpr));
                            }
                        }
                    }
                }
                return subExprs;
            };

            const allSubExprs = findSubExpressions(expr);

            // Sort by complexity (simpler first)
            allSubExprs.sort((a, b) => {
                const complexityA = (a.match(/[&|^~<>()]/g) || []).length;
                const complexityB = (b.match(/[&|^~<>()]/g) || []).length;
                return complexityA - complexityB;
            });

            // Evaluate sub-expressions
            for (const subExpr of allSubExprs) {
                const result = evaluateExpression(subExpr, x);
                if (!result.error) {
                    steps.push({
                        expr: subExpr,
                        value: result.value,
                        description: 'step'
                    });
                }
            }

            // Add final result if different from last step
            if (!seen.has(expr)) {
                const result = evaluateExpression(expr, x);
                if (!result.error) {
                    steps.push({
                        expr: expr,
                        value: result.value,
                        description: 'final'
                    });
                }
            }

            return steps;
        }

        function formatBinaryCompact(num) {
            // Compact binary for intermediate steps - use current width but group by 4

            // Check if number fits in the specified width
            if (!checkFitsInWidth(num, currentBitWidth)) {
                return 'Width Error';
            }

            let binary;

            if (num < 0) {
                const bigNum = BigInt(num);
                const mask = (1n << BigInt(currentBitWidth)) - 1n;
                binary = (bigNum & mask).toString(2).padStart(currentBitWidth, '0');
            } else {
                binary = BigInt(num).toString(2).padStart(currentBitWidth, '0');
            }

            // Group by 4 for readability
            let formatted = '';
            for (let i = 0; i < binary.length; i += 4) {
                formatted += binary.substring(i, i + 4) + ' ';
            }

            return formatted.trim();
        }

        function updateRow(rowId) {
            const input = document.getElementById(`expr-${rowId}`);
            const binaryCell = document.getElementById(`binary-${rowId}`);
            const decimalCell = document.getElementById(`decimal-${rowId}`);

            const expr = input.value.trim();
            const x = parseInt(numberInput.value) || 0;

            if (!expr) {
                binaryCell.innerHTML = '<span style="color: #606060;">-</span>';
                decimalCell.innerHTML = '<span style="color: #606060;">-</span>';
                return;
            }

            const result = evaluateExpression(expr, x);

            if (result.error) {
                binaryCell.innerHTML = `<span class="error-cell">${result.error}</span>`;
                decimalCell.innerHTML = '<span class="error-cell">Error</span>';
            } else {
                const value = typeof result.value === 'bigint' ? result.value : BigInt(result.value);

                // Format binary - check for width error
                const binaryResult = formatBinary64(Number(value));

                if (binaryResult.error) {
                    // Width error - display in red and clear decimal
                    binaryCell.innerHTML = `<span class="error-cell">${binaryResult.message}</span>`;
                    decimalCell.innerHTML = '<span style="color: #606060;">-</span>';
                    return;
                }

                // Main result
                let html = binaryResult.value;

                // Add intermediate steps if expression is complex
                if (expr !== 'x' && (expr.includes('(') || expr.split(/[&|^~<>]/).length > 2)) {
                    const steps = extractIntermediateSteps(expr, x);

                    if (steps.length > 2) { // More than just input and final
                        html += `<div class="toggle-steps" onclick="toggleSteps(${rowId})">
                            <span id="toggle-icon-${rowId}">▼</span> show steps
                        </div>`;
                        html += `<div id="steps-${rowId}" class="intermediate-steps" style="display: none;">`;

                        steps.forEach((step, idx) => {
                            const stepValue = typeof step.value === 'bigint' ? step.value : BigInt(step.value);
                            const label = step.description === 'input' ? '→' :
                                step.description === 'final' ? '=' : '→';

                            html += `<div class="step-row">
                                <span class="step-arrow">${label}</span>
                                <span class="step-expr">${step.expr}</span>
                                <span class="step-binary">${formatBinaryCompact(Number(stepValue))}</span>
                                <span class="step-decimal">= ${stepValue.toString()}</span>
                            </div>`;
                        });

                        html += '</div>';
                    }
                }

                binaryCell.innerHTML = html;
                decimalCell.innerHTML = `<span class="decimal-output">${value.toString()}</span>`;
            }
        }

        function toggleSteps(rowId) {
            const stepsDiv = document.getElementById(`steps-${rowId}`);
            const icon = document.getElementById(`toggle-icon-${rowId}`);

            if (stepsDiv.style.display === 'none') {
                stepsDiv.style.display = 'block';
                icon.textContent = '▲';
            } else {
                stepsDiv.style.display = 'none';
                icon.textContent = '▼';
            }
        }

        function addRow(initialDesc = '', initialExpr = '') {
            const rowId = rowCounter++;
            const row = document.createElement('tr');
            row.id = `row-${rowId}`;

            row.innerHTML = `
                <td>
                    <input type="text"
                           class="expr-input"
                           id="desc-${rowId}"
                           placeholder="e.g., Clear bit"
                           value="${initialDesc}"
                           style="font-size: 12px;">
                </td>
                <td>
                    <input type="text"
                           class="expr-input"
                           id="expr-${rowId}"
                           placeholder="e.g., x << 1"
                           value="${initialExpr}">
                </td>
                <td id="binary-${rowId}" class="binary-output">
                    <span style="color: #606060;">-</span>
                </td>
                <td id="decimal-${rowId}" class="decimal-output">
                    <span style="color: #606060;">-</span>
                </td>
                <td style="text-align: center;">
                    <button class="btn btn-remove" onclick="removeRow(${rowId})">×</button>
                </td>
            `;

            expressionsBody.appendChild(row);

            // Add event listeners
            const input = document.getElementById(`expr-${rowId}`);
            input.addEventListener('input', () => updateRow(rowId));

            // Initial update if expression provided
            if (initialExpr) {
                updateRow(rowId);
            }
        }

        function removeRow(rowId) {
            const row = document.getElementById(`row-${rowId}`);
            if (row) {
                row.remove();
            }
        }

        function updateAllRows() {
            const rows = expressionsBody.querySelectorAll('tr');
            rows.forEach(row => {
                const rowId = row.id.replace('row-', '');
                updateRow(rowId);
            });
        }

        // Initialize with popular bit manipulation hacks from Hacker's Delight

        // === BASIC OPERATIONS ===
        addRow('Original', 'x');
        addRow('Left shift', 'x << 1');
        addRow('Right shift', 'x >> 1');
        addRow('Bitwise NOT', '~x');

        // === RIGHTMOST BIT TRICKS ===
        addRow('Clear lowest 1-bit', 'x & (x - 1)');
        addRow('Isolate lowest 1-bit', 'x & -x');
        addRow('Fill trailing 0s', 'x | (x - 1)');
        addRow('Set rightmost 0-bit', 'x | (x + 1)');
        addRow('Isolate rightmost 0', '~x & (x + 1)');
        addRow('Clear trailing 1s', '~x | (x - 1)');

        // === PROPAGATION TRICKS ===
        addRow('Turn off right 1s', '~(x | -x)');
        addRow('Turn on right 0s', '~(x & -x)');
        addRow('Isolate lowest 1 (v2)', '(x & (x - 1)) ^ x');
        addRow('Mask trailing 0s+1', 'x ^ (x - 1)');
        addRow('Mask trailing 0s', '(x ^ (x - 1)) >> 1');

        // === MASKING & EXTRACTION ===
        addRow('Extract low byte', 'x & 0xFF');
        addRow('Extract low word', 'x & 0xFFFF');
        addRow('Extract 2nd byte', '(x >> 8) & 0xFF');
        addRow('Set sign bit', 'x | 0x80000000');
        addRow('Flip all 32 bits', 'x ^ 0xFFFFFFFF');

        // === SIGN & PARITY ===
        addRow('Get sign bit', '(x >> 31) & 1');
        addRow('Test odd/even', 'x & 1');
        addRow('Sign manipulation', 'x ^ (x >> 31)');

        // === POWER OF 2 DETECTION ===
        addRow('Power of 2 test', 'x & (x - 1)');

        // === ABSOLUTE VALUE ===
        // Note: The branchless absolute value technique was patented (Israeli patent 125,146)
        // but the patent expired on September 13, 2010 and is now public domain.
        // Source: https://graphics.stanford.edu/~seander/bithacks.html
        addRow('Abs value (no branch)', '(x ^ (x >> 31)) - (x >> 31)');
        addRow('Abs value mask', 'x >> 31');
        addRow('Abs value XOR step', 'x ^ (x >> 31)');

        // === SWAP/REVERSE PATTERNS ===
        addRow('Swap adjacent bits', '((x & 0xAAAAAAAA) >> 1) | ((x & 0x55555555) << 1)');
        addRow('Swap 2-bit pairs', '((x & 0xCCCCCCCC) >> 2) | ((x & 0x33333333) << 2)');
        addRow('Swap nibbles', '((x & 0xF0F0F0F0) >> 4) | ((x & 0x0F0F0F0F) << 4)');

        // === POPCNT (Population Count - Count Set Bits) ===
        addRow('POPCNT Step 1', 'x - ((x >> 1) & 0x55555555)');
        addRow('POPCNT Step 2', '(x & 0x33333333) + ((x >> 2) & 0x33333333)');
        addRow('POPCNT Step 3', '(x + (x >> 4)) & 0x0F0F0F0F');
        addRow('POPCNT Step 4', 'x + (x >> 8)');
        addRow('POPCNT Step 5', 'x + (x >> 16)');
        addRow('POPCNT Final', '(x + (x >> 16)) & 0x3F');
        addRow('POPCNT Full 32-bit', '(((((x - ((x >> 1) & 0x55555555)) & 0x33333333) + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) + (((((x - ((x >> 1) & 0x55555555)) & 0x33333333) + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24');

        // === ADVANCED TRICKS ===
        addRow('Next power of 2 (p1)', 'x - 1');
        addRow('Next power of 2 (p2)', '(x - 1) | ((x - 1) >> 1)');
        addRow('Next power of 2 (p3)', '((x - 1) | ((x - 1) >> 1)) | (((x - 1) | ((x - 1) >> 1)) >> 2)');
        addRow('Two\'s complement', '-x');
        addRow('Sign extend 8-bit', '(x & 0xFF) | ((x & 0x80) ? 0xFFFFFF00 : 0)');
        addRow('Sign extend simple', '(x & 0xFF) ^ 0x80');
        addRow('Average (no ovflow)', '(x & 10) + ((x ^ 10) >> 1)');
        addRow('Min via bitwise', 'x & ((x - 42) >> 31) | 42 & ~((x - 42) >> 31)');
        addRow('Set bit N (N=5)', 'x | (1 << 5)');
        addRow('Clear bit N (N=5)', 'x & ~(1 << 5)');
        addRow('Toggle bit N (N=5)', 'x ^ (1 << 5)');
        addRow('Test bit N (N=5)', '(x >> 5) & 1');
        addRow('Byte swap 16-bit', '((x & 0xFF) << 8) | ((x >> 8) & 0xFF)');
        addRow('Byte swap 32-bit', '((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x >> 8) & 0xFF00) | ((x >> 24) & 0xFF)');

        // Auto-select appropriate bit width based on x value
        function autoSelectBitWidth() {
            const x = parseInt(numberInput.value) || 0;
            const suggestedWidth = determineBitWidth(x);

            // Set the appropriate radio button
            document.getElementById(`width${suggestedWidth}`).checked = true;
            currentBitWidth = suggestedWidth;
        }

        // Update all when number changes
        numberInput.addEventListener('input', () => {
            autoSelectBitWidth();
            updateAllRows();
        });

        // Add event listeners to radio buttons
        document.querySelectorAll('input[name="bitWidth"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentBitWidth = parseInt(e.target.value);
                updateAllRows();
            });
        });

        // Set initial bit width
        autoSelectBitWidth();

        // Initial update
        updateAllRows();
    </script>
</body>

</html>